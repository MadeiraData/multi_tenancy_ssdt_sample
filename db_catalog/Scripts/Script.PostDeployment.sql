/*
Post-Deployment Script Template
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.
 Use SQLCMD syntax to include a file in the post-deployment script.
 Example:      :r .\myfile.sql
 Use SQLCMD syntax to reference a variable in the post-deployment script.
 Example:      :setvar TableName MyTable
               SELECT * FROM [$(TableName)]
--------------------------------------------------------------------------------------
*/
GO
SET NOCOUNT ON;

-- Update or Create global params
MERGE INTO dbo.tblGlobalParams AS Target 
USING (VALUES 
   (N'TenantModelDatabase', 'db_tenant_model', NULL, N'Name of the database to be used as a cloneable tenant model')
  ,(N'TenantDatabaseNamePrefix', 'db_tenant_', NULL, NULL)
  ,(N'DBVersion', '1.0.0.0', NULL, N'DB Version')
  ,(N'TenantModelDatabase_RDS_S3_ARN_BackupPath', 'arn:aws:s3:::tenantmodel/db_tenant_model.bak', NULL, 'If on AWS RDS for SQL Server, backup and restore the tenant model to/from this path')
) 
AS Source (ParamName, ParamValueString, ParamValueInt, ParamDescription) 
ON Target.ParamName = Source.ParamName  
WHEN NOT MATCHED BY TARGET THEN 
INSERT (ParamName, ParamValueString, ParamValueInt, ParamDescription) 
VALUES (ParamName, ParamValueString, ParamValueInt, ParamDescription)
WHEN MATCHED AND EXISTS
(
    SELECT [Source].ParamName, [Source].ParamValueString, [Source].ParamValueInt, [Source].ParamDescription
    EXCEPT
    SELECT [Target].ParamName, [Target].ParamValueString, [Target].ParamValueInt, [Target].ParamDescription
) THEN
    UPDATE SET
        ParamValueString = [Source].ParamValueString,
        ParamValueInt = [Source].ParamValueInt,
        ParamDescription = [Source].ParamDescription
;

GO
--MERGE generated by 'sp_generate_merge' stored procedure
--Originally by Vyas (http://vyaskn.tripod.com/code): sp_generate_inserts (build 22)
--Adapted for SQL Server 2008+ by Daniel Nolan (https://twitter.com/dnlnln)

SET NOCOUNT ON

DECLARE @mergeOutput TABLE ( [DMLAction] VARCHAR(6) );
MERGE INTO [tblTenantState] AS [Target]
USING (VALUES
  (0,N'Active')
 ,(1,N'Suspended')
 ,(2,N'Deleted')
 ,(3,N'Hard-Deleted')
) AS [Source] ([StateId],[Name])
ON ([Target].[StateId] = [Source].[StateId])
WHEN MATCHED AND (
	NULLIF([Source].[Name], [Target].[Name]) IS NOT NULL OR NULLIF([Target].[Name], [Source].[Name]) IS NOT NULL) THEN
 UPDATE SET
  [Target].[Name] = [Source].[Name]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([StateId],[Name])
 VALUES([Source].[StateId],[Source].[Name])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
OUTPUT $action INTO @mergeOutput;

DECLARE @mergeError int
 , @mergeCount int, @mergeCountIns int, @mergeCountUpd int, @mergeCountDel int
SELECT @mergeError = @@ERROR
SELECT @mergeCount = COUNT(1), @mergeCountIns = SUM(IIF([DMLAction] = 'INSERT', 1, 0)), @mergeCountUpd = SUM(IIF([DMLAction] = 'UPDATE', 1, 0)), @mergeCountDel = SUM (IIF([DMLAction] = 'DELETE', 1, 0)) FROM @mergeOutput
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [tblTenantState]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[tblTenantState] rows affected by MERGE: ' + CAST(COALESCE(@mergeCount,0) AS VARCHAR(100)) + ' (Inserted: ' + CAST(COALESCE(@mergeCountIns,0) AS VARCHAR(100)) + '; Updated: ' + CAST(COALESCE(@mergeCountUpd,0) AS VARCHAR(100)) + '; Deleted: ' + CAST(COALESCE(@mergeCountDel,0) AS VARCHAR(100)) + ')' ;
 END
GO

DECLARE @mergeOutput TABLE ( [DMLAction] VARCHAR(6) );
MERGE INTO dbo.[tblTenantModelDataTables] AS [Target]
USING (VALUES
  (1,N'dbo',N'tblGlobalParams')
 ,(2,N'dbo',N'ProductSubCategory')
 ,(3,N'dbo',N'ProductCategory')
) AS [Source] ([ExecutionOrder],[SchemaName],[TableName])
ON ([Target].[SchemaName] = [Source].[SchemaName])
AND ([Target].[TableName] = [Source].[TableName])
WHEN MATCHED AND [Target].[ExecutionOrder] <> [Source].[ExecutionOrder] THEN
	UPDATE SET [ExecutionOrder] = [Source].[ExecutionOrder]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([SchemaName],[TableName],[ExecutionOrder])
 VALUES([Source].[SchemaName],[Source].[TableName],[Source].[ExecutionOrder])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
OUTPUT $action INTO @mergeOutput;

DECLARE @mergeError int
 , @mergeCount int, @mergeCountIns int, @mergeCountUpd int, @mergeCountDel int
SELECT @mergeError = @@ERROR
SELECT @mergeCount = COUNT(1), @mergeCountIns = SUM(IIF([DMLAction] = 'INSERT', 1, 0)), @mergeCountUpd = SUM(IIF([DMLAction] = 'UPDATE', 1, 0)), @mergeCountDel = SUM (IIF([DMLAction] = 'DELETE', 1, 0)) FROM @mergeOutput
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [tblTenantModelDataTables]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[tblTenantModelDataTables] rows affected by MERGE: ' + CAST(COALESCE(@mergeCount,0) AS VARCHAR(100)) + ' (Inserted: ' + CAST(COALESCE(@mergeCountIns,0) AS VARCHAR(100)) + '; Updated: ' + CAST(COALESCE(@mergeCountUpd,0) AS VARCHAR(100)) + '; Deleted: ' + CAST(COALESCE(@mergeCountDel,0) AS VARCHAR(100)) + ')' ;
 END
GO


SET NOCOUNT OFF
GO

DECLARE @mergeOutput TABLE ( [DMLAction] VARCHAR(6) );
MERGE INTO dbo.[tblServiceTypes] AS [Target]
USING (VALUES
  (1,N'LegacyService', N'Tenant Legacy Service', 1,120,360,10,1440,1440)
 ,(2,N'WebService', N'Web Service', 0,60*90,360,10,1440,1440)
) AS [Source] ([TypeId],[TypeName],[TypeDescription],[EnableTenantLoadBalancing],[ServiceHeartbeatThresholdSeconds],[TenantActivityThresholdMinutes],[ServiceHeartbeatFrequencySeconds],[ServiceInactivityToDeleteMinutes],[ServiceTenantChangeEventsRetentionMinutes])
ON ([Target].[TypeId] = [Source].[TypeId])
WHEN MATCHED AND EXISTS
    (
        SELECT [Source].*
        EXCEPT
        SELECT [Target].*
    ) THEN
 UPDATE SET
    [TypeName] = [Source].[TypeName],
    [TypeDescription] = [Source].[TypeDescription],
    [EnableTenantLoadBalancing] = [Source].[EnableTenantLoadBalancing],
    [ServiceHeartbeatThresholdSeconds] = [Source].[ServiceHeartbeatThresholdSeconds],
    [TenantActivityThresholdMinutes] = [Source].[TenantActivityThresholdMinutes],
    [ServiceHeartbeatFrequencySeconds] = [Source].[ServiceHeartbeatFrequencySeconds],
    [ServiceInactivityToDeleteMinutes] = [Source].[ServiceInactivityToDeleteMinutes],
    [ServiceTenantChangeEventsRetentionMinutes] = [Source].[ServiceTenantChangeEventsRetentionMinutes]
WHEN NOT MATCHED BY TARGET THEN
 INSERT([TypeId],[TypeName],[TypeDescription],[EnableTenantLoadBalancing],[ServiceHeartbeatThresholdSeconds],[TenantActivityThresholdMinutes],[ServiceHeartbeatFrequencySeconds],[ServiceInactivityToDeleteMinutes],[ServiceTenantChangeEventsRetentionMinutes])
 VALUES([TypeId],[TypeName],[TypeDescription],[EnableTenantLoadBalancing],[ServiceHeartbeatThresholdSeconds],[TenantActivityThresholdMinutes],[ServiceHeartbeatFrequencySeconds],[ServiceInactivityToDeleteMinutes],[ServiceTenantChangeEventsRetentionMinutes])
WHEN NOT MATCHED BY SOURCE THEN 
 DELETE
OUTPUT $action INTO @mergeOutput;

DECLARE @mergeError int
 , @mergeCount int, @mergeCountIns int, @mergeCountUpd int, @mergeCountDel int
SELECT @mergeError = @@ERROR
SELECT @mergeCount = COUNT(1), @mergeCountIns = SUM(IIF([DMLAction] = 'INSERT', 1, 0)), @mergeCountUpd = SUM(IIF([DMLAction] = 'UPDATE', 1, 0)), @mergeCountDel = SUM (IIF([DMLAction] = 'DELETE', 1, 0)) FROM @mergeOutput
IF @mergeError != 0
 BEGIN
 PRINT 'ERROR OCCURRED IN MERGE FOR [tblServiceTypes]. Rows affected: ' + CAST(@mergeCount AS VARCHAR(100)); -- SQL should always return zero rows affected
 END
ELSE
 BEGIN
 PRINT '[tblServiceTypes] rows affected by MERGE: ' + CAST(COALESCE(@mergeCount,0) AS VARCHAR(100)) + ' (Inserted: ' + CAST(COALESCE(@mergeCountIns,0) AS VARCHAR(100)) + '; Updated: ' + CAST(COALESCE(@mergeCountUpd,0) AS VARCHAR(100)) + '; Deleted: ' + CAST(COALESCE(@mergeCountDel,0) AS VARCHAR(100)) + ')' ;
 END
GO
PRINT N'Finished deploying DB Version ' + dbo.GetDBVersion()